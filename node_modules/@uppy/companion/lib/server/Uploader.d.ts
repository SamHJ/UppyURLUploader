/// <reference types="node" />
export = Uploader;
declare class Uploader {
    /**
     * returns a substring of the token. Used as traceId for logging
     * we avoid using the entire token because this is meant to be a short term
     * access token between uppy client and companion websocket
     *
     * @param {string} token the token to Shorten
     * @returns {string}
     */
    static shortenToken(token: string): string;
    static reqToOptions(req: any, size: any): {
        companionOptions: any;
        endpoint: any;
        uploadUrl: any;
        protocol: any;
        metadata: any;
        httpMethod: any;
        useFormData: any;
        size: any;
        fieldname: any;
        pathPrefix: string;
        storage: any;
        s3: {
            client: any;
            options: any;
        };
        headers: any;
        chunkSize: any;
    };
    /**
     * Uploads file to destination based on the supplied protocol (tus, s3-multipart, multipart)
     * For tus uploads, the deferredLength option is enabled, because file size value can be unreliable
     * for some providers (Instagram particularly)
     *
     * @typedef {object} UploaderOptions
     * @property {string} endpoint
     * @property {string=} uploadUrl
     * @property {string} protocol
     * @property {number} size
     * @property {string=} fieldname
     * @property {string} pathPrefix
     * @property {any=} s3
     * @property {any} metadata
     * @property {any} companionOptions
     * @property {any=} storage
     * @property {any=} headers
     * @property {string=} httpMethod
     * @property {boolean=} useFormData
     * @property {number=} chunkSize
     *
     * @param {UploaderOptions} options
     */
    constructor(options: {
        endpoint: string;
        uploadUrl?: string | undefined;
        protocol: string;
        size: number;
        fieldname?: string | undefined;
        pathPrefix: string;
        s3?: any | undefined;
        metadata: any;
        companionOptions: any;
        storage?: any | undefined;
        headers?: any | undefined;
        httpMethod?: string | undefined;
        useFormData?: boolean | undefined;
        chunkSize?: number | undefined;
    });
    options: {
        endpoint: string;
        uploadUrl?: string | undefined;
        protocol: string;
        size: number;
        fieldname?: string | undefined;
        pathPrefix: string;
        s3?: any | undefined;
        metadata: any;
        companionOptions: any;
        storage?: any | undefined;
        headers?: any | undefined;
        httpMethod?: string | undefined;
        useFormData?: boolean | undefined;
        chunkSize?: number | undefined;
    };
    token: string;
    path: string;
    uploadFileName: any;
    streamsEnded: boolean;
    uploadStopped: boolean;
    writeStream: fs.WriteStream;
    /** @type {number} */
    emittedProgress: number;
    storage: any;
    _paused: boolean;
    /**
     * the number of bytes written into the streams
     */
    get bytesWritten(): number;
    /**
     * Validate the options passed down to the uplaoder
     *
     * @param {UploaderOptions} options
     * @returns {boolean}
     */
    validateOptions(options: {
        endpoint: string;
        uploadUrl?: string | undefined;
        protocol: string;
        size: number;
        fieldname?: string | undefined;
        pathPrefix: string;
        s3?: any | undefined;
        metadata: any;
        companionOptions: any;
        storage?: any | undefined;
        headers?: any | undefined;
        httpMethod?: string | undefined;
        useFormData?: boolean | undefined;
        chunkSize?: number | undefined;
    }): boolean;
    _errRespMessage: string;
    hasError(): boolean;
    /**
     * returns a substring of the token. Used as traceId for logging
     * we avoid using the entire token because this is meant to be a short term
     * access token between uppy client and companion websocket
     */
    get shortToken(): string;
    /**
     *
     * @param {Function} callback
     */
    onSocketReady(callback: Function): void;
    cleanUp(): void;
    /**
     *
     * @param {Error} err
     * @param {string | Buffer | Buffer[]} chunk
     */
    handleChunk(err: Error, chunk: string | Buffer | Buffer[]): void;
    endStreams(): void;
    getResponse(): {
        body: {
            message: string;
            token?: undefined;
        };
        status: number;
    } | {
        body: {
            token: string;
            message?: undefined;
        };
        status: number;
    };
    /**
     * @typedef {{action: string, payload: object}} State
     * @param {State} state
     */
    saveState(state: {
        action: string;
        payload: object;
    }): void;
    /**
     * This method emits upload progress but also creates an "upload progress" illusion
     * for the waiting period while only download is happening. Hence, it combines both
     * download and upload into an upload progress.
     *
     * @see emitProgress
     * @param {number=} bytesUploaded the bytes actually Uploaded so far
     */
    emitIllusiveProgress(bytesUploaded?: number | undefined): void;
    /**
     *
     * @param {number} bytesUploaded
     * @param {number | null} bytesTotal
     */
    emitProgress(bytesUploaded: number, bytesTotal: number | null): void;
    /**
     *
     * @param {string} url
     * @param {object} extraData
     */
    emitSuccess(url: string, extraData?: object): void;
    /**
     *
     * @param {Error} err
     * @param {object=} extraData
     */
    emitError(err: Error, extraData?: object | undefined): void;
    /**
     * start the tus upload
     */
    uploadTus(): void;
    tus: tus.Upload;
    uploadMultipart(): void;
    _onMultipartComplete(error: any, response: any, body: any, bytesUploaded: any): void;
    /**
     * Upload the file to S3 using a Multipart upload.
     */
    uploadS3Multipart(): void;
    /**
     * Upload a stream to S3.
     */
    _uploadS3MultipartStream(stream: any): void;
    s3Upload: any;
}
declare namespace Uploader {
    const FILE_NAME_PREFIX: string;
    const STORAGE_PREFIX: string;
}
import fs = require("fs");
import tus = require("tus-js-client");
